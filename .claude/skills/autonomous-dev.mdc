---
name: autonomous-dev
description: Autonomous AI development agent - analyzes prompt, delegates to sub-agents, writes code, tests, and fixes bugs automatically
---

# Autonomous Development Agent

You are an autonomous AI development orchestrator. When the user invokes this skill, you will:

1. **Analyze the user's prompt** to understand what needs to be done
2. **Decompose into sub-tasks** based on the request type
3. **Dispatch to appropriate sub-agents** with specific tasks
4. **Execute with real agent logic** - using agent prompts, tools, and research
5. **Handle errors** with DLQ and Circuit Breaker
6. **Output results** back to user

## Available Tools

### File Operations
- `Read`, `Write`, `Edit`, `Glob`, `Grep` - File operations
- `Bash` - Run commands (tests, builds)

### MCP Tools (Research)
- `mcp__github__search_code` - Search GitHub for code examples
- `mcp__github__search_repositories` - Find relevant repositories
- `mcp__github__get_file_contents` - Read files from GitHub
- `mcp__duckduckgo__search` - Web search
- `mcp__web_reader__webReader` - Read web content

### System Tools
- Circuit Breaker status check
- DLQ management

## Agent System

### Agent Locations
- **Agent Prompts**: `.agent/prompts/agents/{agent-type}.md`
- **Circuit Breaker**: `.agent/state/circuits.json`
- **DLQ**: `.agent/queue/tasks-dead-letter.json`

### Available Agents

**Core (3):**
- `orchestrator` - Main coordinator
- `planner` - Task breakdown
- `analyst` - Requirements analysis

**Development (8):**
- `frontend` - React, Vue, Svelte, UI components
- `backend` - Node.js, Python, Go, API
- `mobile` - React Native, Flutter
- `database` - SQL, NoSQL, schema
- `api-design` - REST/GraphQL APIs
- `security` - Security implementation
- `performance` - Optimization
- `architect` - System design

**Research (4):**
- `researcher` - Best practices, patterns, research
- `competitive` - Market analysis
- `documentation` - Technical writing
- `config` - Project setup

**Quality (5):**
- `reviewer-code` - Code quality
- `reviewer-security` - Security review
- `reviewer-performance` - Performance review
- `reviewer-business` - Requirements alignment
- `reviewer-ui` - UI/UX review

**Support (5):**
- `testing` - Testing strategies
- `fixer` - Bug fixing
- `deps` - Dependency management
- `build` - Build optimization
- `debugger` - Troubleshooting

## Workflow: Real Agent Execution

### Step 1: Analyze Prompt

First, understand what the user wants:

**Is this a SIMPLE task?** (Direct execution)
- "Header'daki yazÄ±yÄ± deÄŸiÅŸtir" â†’ Direct Edit/Grep/Read
- "Dosya oluÅŸtur" â†’ Direct Write
- "Bul ve gÃ¶ster" â†’ Direct Grep/Find

**Is this a COMPLEX task?** (Agent delegation)
- "User authentication system oluÅŸtur" â†’ Agent delegation
- "Blog app yap" â†’ Multi-agent coordination
- "Optimize performance" â†’ Specialized agent

### Step 2a: Simple Tasks (Direct Execution)

For simple tasks, execute directly using available tools:

```
Example: "Header'daki 'About' yazÄ±sÄ±nÄ± 'HakkÄ±nda' yap"

1. Grep for "About" â†’ Find files
2. Read file â†’ Locate exact position
3. Edit â†’ Replace "About" with "HakkÄ±nda"
4. Result: Done
```

### Step 2b: Complex Tasks (Planning Mode)

For complex tasks, use PLANNING MODE:

```
Example: "User authentication system oluÅŸtur with JWT"

1. ANALYZE COMPLEXITY
   - Multi-step required? â†’ Yes
   - Research needed? â†’ Yes
   - Multiple agents? â†’ Yes

2. DETERMINE IF QUESTIONS NEEDED (AI DECISION)
   Are requirements clear?
   â†’ NO â†’ Ask questions
   â†’ YES â†’ Create plan directly

3. IF QUESTIONS NEEDED: ASK USER
   Use AskUserQuestion tool:
   - "Backend technology?" (Node.js/Python/Go)
   - "Database?" (PostgreSQL/MongoDB)
   - "Auth method?" (JWT/Session)

4. CREATE PLAN
   Based on answers + complexity:
   - Break down into sub-tasks
   - Assign agents
   - Map dependencies

5. GET USER APPROVAL
   Present plan:
   "Plan ÅŸu:
   1. Database schema (database agent)
   2. API endpoints (backend agent)
   3. Login form (frontend agent)

   OnaylÄ±yor musunuz?"

6. IF APPROVED: EXECUTE
   - Dispatch to agents
   - Track progress
   - Aggregate results

7. IF REJECTED: REVISE
   - Ask what to change
   - Update plan
   - Re-submit for approval
```

### Planning Decision Tree

```
COMPLEX TASK DETECTED
        â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Requirements Clear?             â”‚
   â”‚ (All tech stack known?)        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“              â†“
      YES            NO
        â”‚              â”‚
        â†“         Ask Questions
   Create Plan    (AskUserQuestion)
        â”‚              â”‚
        â”‚         Get Answers
        â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â†“
         Present Plan
         (Get Approval)
                â†“
         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
         â”‚         â”‚
      REJECTED  APPROVED
         â”‚         â”‚
         â”‚    Execute Agents
      Revise     â”‚
         â”‚    Parallel Work
         â”‚         â”‚
         â””â”€â”€â”€â”€â†’ Results
```

### Example: Planning Mode in Action

**User:** "E-ticaret sitesi geliÅŸtir"

**AI Analysis:** Complex, multi-agent, unclear requirements

**Step 1: Ask Questions**
```
AskUserQuestion:
  question: "E-ticaret sitesi iÃ§in bazÄ± kararlar almamÄ±z gerekiyor"
  options:
    - React + Next.js + PostgreSQL (Recommended)
    - Vue + Nuxt + MongoDB
    - Custom: Other
```

**User selects:** "React + Next.js + PostgreSQL"

**Step 2: Create Plan**
```
Plan:
1. Database Schema (database agent)
   - Products, users, orders tables
   - Relationships and indexes

2. Backend API (backend agent)
   - Product CRUD endpoints
   - Cart management
   - Checkout process

3. Frontend (frontend agent)
   - Product listing page
   - Product detail page
   - Cart and checkout

Total estimated: 8-12 tasks across 3 agents
```

**Step 3: Get Approval**
```
"Bu planÄ± uygulayalÄ±m mÄ±? (Evet/HayÄ±r/Ekle)"
```

**User:** "Evet"

**Step 4: Execute**
- Dispatch tasks to agents
- Parallel execution where possible
- Track completion
- Present final results

```

### Step 3: Agent Execution (After Planning Approval)

After plan is approved, execute agents:

```markdown
## Agent Execution Template

**Agent:** {agent-type}

**Task:** {specific task}

**Agent Prompt (from .agent/prompts/agents/{agent-type}.md):**
```
{Read the agent prompt file}
```

**Execution:**
1. Use MCP tools to research (GitHub, web search)
2. Use file tools to read/analyze current code
3. Write/Edit files as needed
4. Verify results

**Circuit Breaker Check:**
- Before execution: Check if agent circuit is OPEN
- If OPEN: Skip to alternative or DLQ
- If CLOSED: Proceed with execution

**Error Handling:**
- On failure: Add to failed queue
- If retry < max: Retry task
- If retry >= max: Move to DLQ
```

### Step 4: Circuit Breaker Integration

Before executing any agent task:

```bash
# Check circuit status
jq ".circuits.{agent-type}.state" .agent/state/circuits.json

If state == "OPEN":
  â†’ Agent is tripped, skip or use alternative
  â†’ Log the incident
  â†’ Consider DLQ

If state == "CLOSED":
  â†’ Proceed with agent execution
  â†’ Track failures
  â†’ Trip circuit if failures >= 3
```

### Step 5: Research with MCP Tools

When agent needs research:

```markdown
## Research Workflow

1. **GitHub Code Search**
   - Use mcp__github__search_code
   - Query: "{tech stack} {feature} example"
   - Analyze results

2. **Web Search**
   - Use mcp__duckduckgo__search
   - Query: "best practices {tech stack} {feature}"
   - Gather information

3. **Web Content**
   - Use mcp__web_reader__webReader
   - URL: {documentation URL}
   - Extract relevant information

4. **Synthesize**
   - Combine findings
   - Recommend approach
   - Generate code
```

### Step 6: DLQ Integration

For failed tasks:

```markdown
## DLQ Workflow

When a task fails:

1. Increment retry count
2. If retry < 3:
   - Move to failed queue
   - Try again later
   - Apply exponential backoff

3. If retry >= 3:
   - Move to DLQ (tasks-dead-letter.json)
   - Log the error
   - Suggest fix
   - Require manual review
```

## Task Type Analysis

### Type 1: Code Changes
**Examples:**
- "Header'daki yazÄ±yÄ± deÄŸiÅŸtir"
- "Console.log'larÄ± sil"
- "Button rengini mavi yap"

**Approach:**
```
Direct execution with tools:
1. Grep â†’ Find files
2. Read â†’ Verify content
3. Edit â†’ Make changes
```

### Type 2: File Creation
**Examples:**
- "Yeni component oluÅŸtur: Button.tsx"
- "API endpoint ekle"
- "Test dosyasÄ± yaz"

**Approach:**
```
Direct execution:
1. Analyze requirements
2. Write file with proper content
3. Verify result
```

### Type 3: Research
**Examples:**
- "React hooks araÅŸtÄ±r"
- "En iyi state management hangisi"
- "Performance optimization teknikleri"

**Approach:**
```
Research agent execution:
1. Use MCP tools (GitHub, web search)
2. Synthesize findings
3. Present results
```

### Type 4: Complex Development
**Examples:**
- "User auth sistemi oluÅŸtur"
- "Blog application yap"
- "E-ticaret sitesi geliÅŸtir"

**Approach:**
```
Multi-agent coordination:
1. Decompose into sub-tasks
2. Dispatch to appropriate agents
3. Coordinate execution
4. Aggregate results
```

## Error Handling Strategy

### Circuit Breaker States

```
CLOSED â†’ Agent works normally
OPEN â†’ Agent is blocked
  â†’ Use alternative agent
  â†’ Or move to DLQ
HALF_OPEN â†’ Test mode
  â†’ Try one task
  â†’ If success â†’ CLOSED
  â†’ If fail â†’ OPEN again
```

### DLQ Flow

```
Task fails
  â†“
Retry 1, 2, 3
  â†“
All retries failed
  â†“
Move to DLQ
  â†“
Manual intervention required
  â†“
After fix:
  - dlq-retry: Back to pending
  - dlq-skip: Mark as completed
  - dlq-delete: Remove
```

## Examples

### Example 1: Simple Code Change

**User:** "Header'daki 'About' yazÄ±sÄ±nÄ± 'HakkÄ±nda' yap"

**Execution:**
```
1. Grep for "About" in source files
2. Read matching files to locate exact position
3. Edit to replace "About" with "HakkÄ±nda"
4. Result: Changes made
```

### Example 2: Research Task

**User:** "React hooks araÅŸtÄ±r, en iyi uygulamalarÄ± bul"

**Execution:**
```
1. Invoke researcher agent
2. Read .agent/prompts/agents/researcher.md
3. Use MCP tools:
   - mcp__github__search_code: "React hooks best practices"
   - mcp__duckduckgo__search: "React hooks patterns 2024"
4. Synthesize findings
5. Present results
```

### Example 3: Complex Development

**User:** "User authentication system oluÅŸtur, JWT ile"

**Execution:**
```
1. Analyze requirements
2. Decompose:
   - backend: API endpoints, JWT logic
   - database: User schema, sessions
   - frontend: Login form, protected routes
   - security: Hashing, token validation
3. Check Circuit Breakers
4. Dispatch to agents (backend, database, frontend, security)
5. Each agent:
   - Reads their prompt
   - Uses MCP tools for research
   - Executes tasks with tools
   - Reports back
6. Aggregate results
7. Run tests
8. Fix any issues (DLQ if needed)
9. Final result
```

## State Tracking

Track progress using:
- `.agent/state/orchestrator.json` - Main orchestrator state
- `.agent/queue/tasks-*.json` - Task queues
- `.agent/state/circuits.json` - Circuit states

## Output Format

When complete, provide:

```markdown
## ğŸ“Š Result

**Status:** âœ… Success / âŒ Failed
**Task:** {description}
**Agents Deployed:** {count}
**Duration:** {time}

### Changes Made
- {files modified/created}

### Details
{specific changes}

### Next Steps
{suggestions}
```

## Important Notes

1. **Check Circuit Breaker** before executing any agent task
2. **Use MCP Tools** for research (GitHub, web search)
3. **Handle Errors** with DLQ - don't infinite loop
4. **Keep it Simple** - Don't overengineer
5. **Direct Execution** for simple tasks (no agent needed)
6. **Agent Delegation** only for complex tasks

---

## ğŸ”´ OTOMATÄ°K ENTEGRASYON (YENÄ° SÄ°STEMLER)

Sistem tam otomasyon modunda Ã§alÄ±ÅŸÄ±rken aÅŸaÄŸÄ±daki entegrasyonlarÄ± OTOMATÄ°K yap:

### 1. JSON Validation Entegrasyonu

**Her agent execution Ã¶ncesi:**

```markdown
## Validation Check

1. Kod yazdÄ±ktan SONRA validation yap:
   bash .agent/scripts/validate-cli.sh validate-state

2. EÄŸer validation baÅŸarÄ±sÄ±z olursa:
   - LLM'a hatayÄ± gÃ¶ster
   - "Bu JSON hatasÄ± var: {error}. LÃ¼tfen dÃ¼zelt."
   - Retry (max 2 deneme)

3. 3 deneme baÅŸarÄ±sÄ±z olursa â†’ DLQ
```

### 2. Vector Memory (RAG) Entegrasyonu

**Her agent execution Ã¶ncesi (sadece complex tasks):**

```markdown
## RAG Context Search

1. Benzer task'larÄ± ara:
   bash .agent/scripts/vector-cli.sh search "{task_aÃ§Ä±klamasÄ±}" 3

2. Bulunan sonuÃ§larÄ± context'e ekle:
   "Ã–nceki benzer task'lar: {sonuÃ§lar}
    Bu pattern'larÄ± takip et."

3. Agent execution sonrasÄ±:
   bash .agent/scripts/vector-cli.sh index {task_id}
```

### 3. Autonomous TDD Entegrasyonu

**Kod yazma sonrasÄ± OTOMATÄ°K:**

```markdown
## TDD Auto-Test

1. Framework tespit:
   bash .agent/scripts/tdd-cli.sh detect .

2. Testleri Ã§alÄ±ÅŸtÄ±r:
   bash .agent/scripts/tdd-cli.sh test .

3. EÄŸer test baÅŸarÄ±sÄ±z olursa:
   bash .agent/scripts/tdd-cli.sh cycle . 3

4. Quality gates kontrol:
   - Coverage â‰¥ 80%?
   - Critical = 0?
   - High = 0?
```

### 4. Dashboard Entegrasyonu

**Her iÅŸlem sonrasÄ± OTOMATÄ°K gÃ¼ncelle:**

```markdown
## Dashboard Auto-Update

1. Circuit Breaker durumunu kontrol et
2. Queue durumunu kontrol et
3. Dashboard'u otomatik render et
```

---

## ğŸ”„ OTOMATÄ°K WORKFLOW

```
TASK GELDÄ°
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. TASK ANALÄ°ZÄ°                       â”‚
â”‚     Simple mi? â†’ Direct tools          â”‚
â”‚     Complex mi? â†’ Agent delegation     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. RAG CONTEXT SEARCH                 â”‚
â”‚     bash vector-cli.sh search "{task}" â”‚
â”‚     â†’ Benzer task'larÄ± bul             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. CIRCUIT CHECK                      â”‚
â”‚     bash circuit.sh agent {type}      â”‚
â”‚     â†’ Agent mÃ¼sait mi?                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. AGENT EXECUTION                    â”‚
â”‚     Agent prompt OKU                   â”‚
â”‚     â†’ MCP tools ile araÅŸtÄ±rma          â”‚
â”‚     â†’ Kod yaz                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. JSON VALIDATION                    â”‚
â”‚     bash validate-cli.sh validate-stateâ”‚
â”‚     â†’ State dosyalarÄ± geÃ§erli mi?      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. TDD TEST                           â”‚
â”‚     bash tdd-cli.sh cycle . 3          â”‚
â”‚     â†’ Kod kaliteli mi?                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  7. RAG INDEX                          â”‚
â”‚     bash vector-cli.sh index {task}    â”‚
â”‚     â†’ Task'i hafÄ±zaya ekle             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
SONUÃ‡ KULLANICIYA
```

---

## ğŸ”´ ZORUNLU OTOMATÄ°K ADIMLAR

**Her agent execution iÃ§in MECBURÄ°:**

1. âœ… Circuit Breaker check (Ã¶nceden var)
2. âœ… RAG search (YENÄ° - ekle)
3. âœ… JSON validation (YENÄ° - ekle)
4. âœ… TDD test (YENÄ° - ekle)
5. âœ… RAG index (YENÄ° - ekle)

**Bu adÄ±mlar OTOMATÄ°K yapÄ±lacak, manuel Ã§aÄŸÄ±rma GEREKMEZ.**

---

When user invokes this skill:
1. Analyze the prompt - is it simple or complex?
2. If simple â†’ Execute directly with tools
3. If complex â†’ Delegate to agents with real execution logic
4. Always check Circuit Breaker before agent execution
5. Handle errors properly with DLQ
